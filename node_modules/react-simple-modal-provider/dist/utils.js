var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { PREFIX, ERROR_MESSAGES } from './constants';
const $ = (selector, parent = document) => parent.querySelector(selector);
const stateBundler = (setFuncArr = [], willState) => setFuncArr.forEach((set) => set(willState));
const hash = (id) => {
    let hash = 0, i = 0, len = id.length;
    while (i < len) {
        hash = ((hash << 5) - hash + id.charCodeAt(i++)) << 0;
    }
    hash = hash + 2147483647 + 1;
    return `${PREFIX.HASH}${hash}`;
};
const defer = (ms) => __awaiter(void 0, void 0, void 0, function* () { return yield new Promise((r) => setTimeout(r, ms)); });
const checkRequiredProps = ({ id, consumer, isOpen, setOpen, }) => {
    if (typeof id !== 'string')
        throw new Error(ERROR_MESSAGES.MODAL_ID_TYPE_ERROR(id));
    if (!id || !consumer || isOpen === undefined || !setOpen)
        throw new Error(ERROR_MESSAGES.MODAL_NOT_ENOUGH_PROPS(id));
};
const getModalStyle = ({ hashId, duration, vertical, horizontal, width, height, radius, overlayColor, backgroundColor, animation, }) => {
    return `
        .${PREFIX.PORTAL}${hashId} .overlay-base {
            position: fixed;
            top: 0;
            bottom: 0;
            right: 0;
            left: 0;
            width: 100%;
            height: 100%;
            outline: 0;
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0);
            transition-property: background-color, opacity;
            transition-timing-function: ease-in-out;
            transition-duration: ${duration}ms;
        }

        .${PREFIX.PORTAL}${hashId} .overlay-after {
            background-color: ${overlayColor};
        }

        .${PREFIX.PORTAL}${hashId} .overlay-before {
            background-color: rgba(0, 0, 0, 0);
        }

        .${PREFIX.PORTAL}${hashId} .content-base {
            position: relative;
            bottom: ${vertical}px;
            left: ${horizontal}px;
            overflow: hidden;
            outline: 0;
            transition-timing-function: ease-in-out;
            transition-property: ${animation.type};
            ${animation.base};
            transition-duration: ${duration}ms;
            visibility: hidden;
            pointer-events: none;

            min-width: ${width}px;
            min-height: ${height}px;
            border-radius: ${radius}px;
            background-color: ${backgroundColor};
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .${PREFIX.PORTAL}${hashId} .content-after {
            visibility: visible;
            pointer-events: auto;
            ${animation.after};
        }

        .${PREFIX.PORTAL}${hashId} .content-before {
            ${animation.before};
        }
    `.replace(/\n|  /g, '');
};
const throttle = (callback, waitTime) => {
    let timerId = null;
    return (e) => {
        if (timerId)
            return;
        timerId = setTimeout(() => {
            callback.call(null, e);
            timerId = null;
        }, waitTime);
    };
};
const startDragHandler = (e) => {
    const { currentTarget, clientX, clientY, } = e;
    const move = ({ clientX, clientY }) => {
        currentTarget.style.top = clientY - offsetY + 'px';
        currentTarget.style.left = clientX - offsetX + 'px';
    };
    const onMouseMoveThrottle = throttle(({ clientX, clientY }) => {
        if (clientX <= 0 || clientY <= 0 || clientX >= innerWidth || clientY >= innerHeight)
            return removeMousemoveEvent();
        move({ clientX, clientY });
    }, 10);
    const removeMousemoveEvent = () => {
        document.removeEventListener('mousemove', onMouseMoveThrottle);
        currentTarget.onmouseup = null;
    };
    document.addEventListener('mousemove', onMouseMoveThrottle);
    currentTarget.onmouseup = removeMousemoveEvent;
    const offsetX = clientX - currentTarget.getBoundingClientRect().left;
    const offsetY = clientY - currentTarget.getBoundingClientRect().top;
    move({ clientX, clientY });
    currentTarget.style.width = currentTarget.offsetWidth + 'px';
    currentTarget.style.height = currentTarget.offsetHeight + 'px';
    currentTarget.style.position = 'fixed';
    currentTarget.style.zIndex = '10000';
};
const checkPropsCondition = (props) => {
    return (props !== null &&
        typeof props === 'object' &&
        props.constructor &&
        props.constructor.name !== 'SyntheticBaseEvent');
};
const checkCustomStyle = ({ id, width, height, backgroundColor, }) => {
    if ((!!width || !!height) && backgroundColor === 'transparent')
        console.warn(ERROR_MESSAGES.MODAL_CUSTOM_STYLE_WARN(id));
};
export { $, stateBundler, hash, defer, checkRequiredProps, getModalStyle, throttle, startDragHandler, checkPropsCondition, checkCustomStyle, };
